#1장 프로토콜 시작

2015 애플이 최초로 프로토콜 지향 언어 siwft 2를 WWDC에서 발표했구나

프로토콜 지향 프로그래밍은 프로토콜이 전부가 아니구나 뭔가 다른 걸 내포하고 있는 것 같은데 그건 앱을 개발하는 새로운 방법 또는 앱 설계에 대해 생각하게 하는 새로운 방법

앞으로 프로토콜에 대해 배울거 나열되어있는데 프로토콜 기능 요구 사항 정의는 알고..

프로토콜 상속과 컴포지션은 뭐지 프로토콜도 상속해서 쓸 수 있나보다 컴포지션은 구성? 잠깐 봤는데 여러 프로토콜 채택할 수 있는 거였음

프로토콜도 타입의 일종이라고 알고 있음

프로토콜과 다형성은 뗄 수 없음. 어떤 프로토콜을 채택하는 클래스나 구조체는 다형성 덕분에 채택하고 있는 프로토콜 타입으로 취급 될 수 있음~

프로토콜로 연관 타입을 사용하는법? 연관 타입이 뭘까

프로토콜로 델리게이션 패턴 구현은 자주 등장하니 잘 봐두자

프로토콜로 타입 요구 사항을 설계한다? 가 무슨 말일까 어떤 프로토콜 타입을 정의하는 건가?

객체지향 프로그래밍에 기반을 둔 개발자는 인터페이스에 익숙하지.. 인터페이스는 메소드와 프로퍼티 시그니처는 포함하지만 구현체는 포함하지 않음!

인터페이스는 “채택하는 곳에서 인터페이스에서 정의한 기능을 반드시 구현해야 한다는 일종의 계약”

하지만 객체지향 프로그래밍이라고 해서 앱을 설계할 때 인터페이스에 주안을 두진 않음

오히려 객체지향 프로그래밍은 클래스의 계층 구조와 객체들의 상호작용에 중점을 두는구나

클래스에 대한 정의 “클래스는 객체의 프로퍼티와 행위를 단일 타입으로 캡슐화하는 구성체”

반면 프로토콜지향 방식으로 앱을 설계하는 건 클래스 계층 구조가 아닌 프로토콜로 시작해야함(프로토콜 뿐 아니라 다른 것도 있다는데 뭘까)

인터페이스와 마찬가지로 프로토콜도 정의한 요구 사항을 구현하는 것을 약속하는 일종의 계약이다.

클래스, 구조체, 열거형 모두 프로토콜 따를 수 있다. 하지만 인터페이스 보다 훨씬 강력하다? 뭘까?

extension으로 초기값 설정 가능한것?

스위프트 표준 라이브러리는 프로토콜에 기반을 두고있고 프로토콜은 프로토콜지향 프로그래밍의 근간이기 때문에 잘 알고 있어야함! 프로토콜 중요하다

## 프로토콜 문법

프로토콜 정의하는 법은 쉽다. 다중 프로토콜은 가능한거 알지만 자주 쓰는지 모르겠네..라고 하는 순간 타입이 다중 프로토콜을 따르게 하는건 프로토콜지향 프로그래밍에서 아주 중요한 개념이라고 하는구만(프로토콜 컴포지션). 저번 스터디에서 나온 “A는 B가 있다”의 구성 관계와 연관이 있지 않을까?

### 프로퍼티 요구사항

프로토콜의 프로퍼티 요구사항을 정의 할 때 저장프로퍼티인지 연산프로퍼티인지는 구현체한테 맞김

프로토콜은 타입추론 사용 못하니 타입 명시 필수!

get set으로 읽기쓰기 명시 필수. 근데 기본값이 읽기 쓰기인듯 명시 안해줘도 되던데

당연 스태틱 프로퍼티 정의 역시 가능

### 메소드 요구 사항

스태틱 키워드로 인스턴스 메소스나 타입 메소드가 되도록 정의한다는데 무슨차이지?

아아 인스턴스 메소드는 특정 구조체, 열거체, 클래스의 인스턴스에 속한 메소드, 인스턴스를 생성해야 사용 할 수 있군, 타입 메소드는 인스턴스 없이 특정 타입 자체에서 호출 가능! func 앞에 static(=final class) 혹은 class 붙여서 선언 가능. 차이는 서브클래스에서 오버라이드 불가능/ 가능 여부

메소드 매개변수에 기본값 추가 불가

구조체같은 값타입에 속한 메소드가 자신이 속한 구조체 인스턴스를 변경하려고하면 반드시 mutating 키워드 필요~

### 선택 가능한 요구 사항

포토토콜에서 요구 사항 정의할 때 꼭 구현하지 않아도 되도록 선택 가능한 요구 사항으로 정의 할 수도 있구나! 저번 스터디때 해정씨가 말한 거네

프로토콜과 앞에 @obj 키워드 붙이면 된다.

❗중요 오직 클래스에서 @obj 키워드 붙은 프로토콜 채택 할 수 있음. 구조체 열거형은 불가능

프로퍼티 앞에는 @obj optional 키워드 붙여줘야 함. 선택 가능 프로토콜을 채택한 클래스 앞에도 @obj 붙여줘야 하는듯?

## 프로토콜 상속

프로토콜도 상속 가능하네 그것도 여러개를

프로토콜을 채택할 때 그 프로토콜이 상속 받은 상위 프로토콜의 요구 사항도 반드시 구현해야 함

## 프로토콜 컴포지션

타입이 여러 프로토콜을 채용 할 수 있게 해줌

클래스 계층 구조와 비교 했을 때 큰 장점. 단일 상속 언어에서 클래스는 한 개의 슈퍼 클래스만 상속 할 수 있기 때문에~

프로토콜 컴포지션은 요구사항을 단일 프로토콜 혹은 클래스가 아닌 여러 작은 프로토콜로 나눌 수 있게 해줌. 이는 타입 계층의 뎁스 보다는 너비를 증가 시켜줌

꼭 필요한 개념이라는데 어떤 장점이 있는지 보자

프로토콜 컴포지션을 이용하면 각각의 요구 사항을 정의 해 놓은 프로토콜을 필요에 따라 조합해서 쓸 수 있음! 상속을 이용한 클래스 계층 구조는 쓸데 없는 기능을 상속 받아야 하거나 클래스 간 중복 코드가 많이 발생함

## 프로토콜을 타입으로 사용

프로토콜은 일종의 타입으로 취급 된다고 알고 있음

이는 곧 다른 타입과 마찬가지로 프로토콜을 함수의 매개변수나 반환 타입으로 사용 할 수 있다는말~ 변수, 상수, 컬렉션에 대한 타입으로도 역시 가능

SwiftProgrammer와 FootballProgrammer가 Person프로토콜을 따른다면 Person 타입이 들어갈 자리에 두 프로그래머의 각각의 인스턴스가 모두 들어갈 수 있음. 다형성 덕분!

## 프로토콜과 다형성

다형성은 형태가 많다는 뜻. 다형성은 정말 유용한 프로그래밍 기술 중 하나

다형성은 일관된 하나의 인터페이스를 통해 여러 타입과 상호 작용 할 수 있도록 해줌

하나의 인터페이스(프로토콜)를 통해 특정 타입에 접근 할 때 프로토콜을 채택한 타입의 프로퍼티에 접근하기 위해 형 변환을 사용해야 함

## 프로토콜과 형 변환

is 로 특정 타입의 인스턴스인지 확인

as로 인스턴스를 특정 타입으로 다룰 수 있음

where로 특정 타입의 인스턴스의 배열만 반환 할 수 있음

```swift
if person is SwiftProgrammer { }
if let _ = person as? SwiftProgrammer { }
for person in people where person is SwiftProgrammer { }
```

where과 is를 잘 쓰면 원하는 타입의 인스턴스만 분류하기 편하겠다!

## 연관 타입과 프로토콜

연관 타입이란 프로토콜을 정의 할 때 프로토콜 내에서 쓰이는 타입을 플레이스 홀더로 대체 한 뒤에 나중에 프로토콜을 채택하는 타입에서 정의해서 쓸 수 있게 해주는 것.

```swift
protocol Queue {
	associatedtype QueueType // 연관타입
	mutating func addItem(item: QueueType)
	mutating func getItem() -> QueueType?
	func count() -> Int
}
```

Queue 프로토콜을 채택하는 타입에서 addItem과 getItem에 쓰이는 QueueType이라는 타입을 정할 수 있음

비제네릭 클래스 IntQueue에서 Queue구현하는게 나왔는데 어떤 클래스인지 잘 모르겠다. 뒤에 제네릭과 함께 연관 타입을 사용 하는 방법과 차이를 잘 봐야겠다.

제네릭은 컴파일 타임 단계가 아닌 런타임 단계에서 사용할 타입을 정의하게 해주는 것.

아마 Int 대신에 제네릭 T를 이용함 지금은 Int만 사용 가능 하지만 어떤 타입이든 Queue를 구현 할 수 있을듯

## 델리게이션

일종의 디자인 패턴으로 어느 한 타입의 인스턴스가 다른 인스턴스를 대신해서 동작하는 상황에 잘 맞음

동작을 위임(delegatig)하는 인스턴스는 대신 동작하는 인스턴스의 참조를 저장하고 있다가 어떤 동작이 발생하면 델리게이트를 호출함.

델리게이트가 해야 할 일을 프로토콜에 정의해서 구현한다. 대신 동작하는 인스턴스는 이 델리게이트 프로토콜을 채택하고 프로토콜에서 정의한 일을 해야함.

```swift
// 위임 할 동작
protocol DisplayNameDelegate {
	func displayName(name: String)
}

// 동작을 위힘하는 인스턴스
struct Person {
	var displayNameDelegate: DisplayNameDelegate // 대신 동작하는 인스턴스를 저장함

	var firstName = "" {
		didset {
			displayNameDelegate.displayName(name: getFullName()) //동작을 위임 할때 델리게이트 호출
		}
	}

	var lastName = "" {
		didset {
			displayNameDelegate.displayName(name: getFullName()) //동작을 위임 할때 델리게이트 호출
		}
	}

	init(displayNameDelegate: DisplayNameDelegate) {
		self.displayNameDelegate = displayNameDelegate
	}

	func getFullName() -> String {
		return "\(firstName) \(lastName)"
	}
}

//동작을 대신 할 인스턴스
struct MyDisplayNameDelegate: DisplayNameDelegate { //델리게이트 프로토콜을 채택
	func displayName(name: String) {
		print("Name is \(name)")
	}
}

// 델리게이트 패턴으로 어떤 인스턴스에서 다른 인스턴스로 동작을 위임하기
var displayDelegate = MyDisplayDelegate()
var person = Person(displayNameDelegate: displayDelegate)
person.firstName = "Jiho" // Jiho
person.lastName = "Park" // Jiho Park
```

델리게이트 패턴의 이점은 앱의 행위를 바꿀 때 발휘됨.

현재는 MyDisplayNameDelegate에서 print하는 행위를 하고 있지만 행위를 바꾸고싶을때 DisplayNameDelegate 프로토콜을 따르는 새로운 타입의 Delegate를 만들고 Person 타입의 인스턴스에서 사용하기만 하면 된다.

또한 동작을 위임하는 인스턴스와 동작을 대신 하는 인스턴스의 느슨한 결합을 지을 수 있다.

## 프로토콜을 사용해 설계

객체지향 프로그래밍 세계에서 서브클래스를 위한 기본 요구 사항을 포함하는 슈퍼 클래스를 갖는것과 달리 프로토콜지향 프로토콜 세계에서는 슈퍼 클래스 대신 프로토콜을 사용하고 요구 사항을 더 작고 구체적인 프로토콜로 나누기에 적절하다. 프로토콜 상속과 프로토콜 컴포지션, 프로토콜 확장(프로토콜을 따르는 타입에 기능 추가) 등이 사용 됨

## 스위프트 표준 라이브러리의 프로토콜

스위프트 표준 라이브러리에서 프로토콜을 광범위하게 사용하는 것을 볼 수 있음(https://swiftdoc.org)

Dictionary타입은 다섯 개의 서로 다른 프로토콜을 따르고(프로토콜 컴포지션) 그 중 한 개인 Collection프로토콜은 Sequence 프로토콜로부터 요구 사항을 상속받음.
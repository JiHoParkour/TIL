# 4. 제네릭

이 책을 읽기 전 제네릭은 어떤 타입이든 될 수 있음을 나타내는 키워드라고 알고 있었음. 덕분에 제네릭을 사용하면 어떤 타입인지 컴파일 타임에 지정하지 않아도 돼서 유연한 프로그래밍을 할 수 있음

저자는 어떤 얘기를 해줄까? 저자는 저명인사와 제네릭 프로그래밍에 대해 나눈 대화를 잊지 못해 다음 여섯 가지를 다뤄보겠다고 한다.

- 제네릭이란
- 제네릭 함수를 작성하는 방법
- 제네릭 타입을 작성하는 방법
- 제네릭 서브스크립트를 사용하는 방법
- Copy-on-write를 구현하는 방법
- 프로토콜과 제네릭을 사용해 매우 유연하면서도 재사용이 가능한 타입을 설계하는 방법

### **제네릭?**

제네릭은 중복을 피하면서 매우 유연하고 재사용이 가능한 코드를 작성하게 해준다.

가능한 이유는 제네릭 키워드의 뜻이 “아직은 필요한 타입을 알지 못하니 지금은 플레이스홀더를 제공할게 그리고 실행해야 하는 타입에 대해서는 런타임에 알려줄게” 이기 때문이다.

제네릭은 이미 스위프트 언어 자체에서 상당 부분 활용되고 있음

스위프트 표준 라이브러리의 배열은 제네릭을 활용해서 모든 타입의 인스턴스를 포함하는 배열을 생성할 수 있게 해준다.

옵셔널 또한 내부적으로 두 개의 사용 가능한 값인 None과 Some(T)로 이뤄진 열거형으로 정의돼있다.

```swift
enum Optional<T> {
	case None
	case Some(T)
}
```

옵셔널에 nil을 대입하면 None값을 갖게 되고 어떤 값을 대입하면 연관된 적절한 타입의 Some값을 갖게 된다.

여기서  T가 옵셔널과 연관된 타입을 나타낸다. 플레이스홀더는 T나 E가 대부분 문서에서 표준으로 쓰임

### 제네릭 함수

함수를 정의할 때 제네릭을 이용해서 중복코드를 제거할 수 있다.

두 변수의 값을 교환하는 함수를 만들어보자

```swift
func swapInts(a: inout Int, b: inout Int) {
	let tmp = a
	a = b
	b = tmp
}
func swapStrings(a: inout String, b: inout String) {
	let tmp = a
	a = b
	b = tmp
}
.
.
.
```

각각 Int 타입과 String타입의 두 인스턴스를 교환하는 함수이다.

교환하려는 타입이 늘어날 때 마다 함수를 새로 정의해야 하는 번거로움과 매개변수 타입을 제외한 코드의 중복이 생긴다.

```swift
func swapGeneric<T>(a: inout T, b: inout T) {
	let tmp = a
	a = b
	b = tmp
}
```

함수 정의부에 <T>를 제외하면 일반적인 함수 정의와 유사하다.

T는 플레이스홀더이기때문에 어떤 문자도 가능하지만 T(타입), E(요소)가 표준
# 클린아키텍처가 필요한 이유
- 프로그램이 동작하도록 만드는건 쉽게 할 수 있지만 제대로 만들기 위해서는 노력과 훈련이 필요하다.
- 프로그램을 제대로 만들면 지속가능한 개발을 할 수 있다.
- 지속가능한 개발, 즉 적은 인력, 유연한 변경, 낮은 결함률을 보장한다.

# 1장 설계와 아키텍처란?

- 설계는 저수준의 세부사항, 아키텍처는 고수준의 결정사항을 의미한다.
- 두 요소가 모여 전체 설계를 구성한다. 두 요소를 명확하게 나누는 기준은 없다.
- 고수준의 결정사항에서 저수준의 세부사항으로 의사결정이 이루어진다.

- 설계의 목표는 적은 유지보수 인력과 비용, 높은 생산성이다.
- 빠르게 개발하기 위해 설계 없이 개발하지만 시간이 지날수록 개발 비용은 계속 증가할것임.
- 나중에 리팩토링한다고 과신하지만 그럴 일은 없기때문에 처음부터 제대로 개발하는게 가장 좋은 방법

# 2장 두 가지 가치에 대한 이야기

- 소프트웨어는 동작과 구조 두 가지 가치를 지닌다.
- 당장은 동작하는게 중요해보이겠지만 결국 변경 요구사항을 반영 할 수 없게되면 쓸모가 없어지기때문에 종래에는 유연성이 더욱 중요함
- 개발자는 동작의 긴급성과 구조의 중요성 두 가치 사이의 딜레마를 조율하고 해결해야하는 책임이 있다.

# 3장 패러다임 개요

- 바이너리 언어를 사용해 반복문, 분기문, 할당문 등을 이용한 실질적인 프로그래밍, 어셈블러의 등장, 컴파일러의 등장 등의 혁신이 있었지만 더 중요한 어떻게 프로그래밍 할것인지 결정하는 패러다임이 세 가지 등장했다.

- 구조적 프로그래밍 -  지정한 문장으로 이동하는 goto문을 if/then/else do/while/until과 같은 구조로 대체함 ⇒ 프로그램의 제어흐름에 직접적인 규칙(제한)을 부과
- 객체 지향 프로그래밍 - 함수 호출 정보를 메모리의 스택영역(컴파일)에서 프로그래머가 통제 가능한 힙영역(런타임)으로 옮기면 변수가 사라지지 않음. 클래스, 인스턴스 변수, 메서드의 등장! 즉 메모리 내에서 실행 가능한 코드(포인터)를 통제하는 규칙이 생김, 다형성의 등장 ⇒ 프로그램의 제어흐름에 간접적인 규칙(제한) 부과
    - 다형성 : 다양한 형태, 즉 하나의 객체에 다양한 형태의 타입을 대입할 수 있음을 뜻한다.
- 함수형 프로그래밍 - 람다 계산법의 영향을 받음. 람다 계산법의 기초개념은 불변성. 데이터의 값이 변하지 않음. 즉 변수 할당문이 존재하지 않음 ⇒ 할당문에 대한 규칙(제한) 부과

- 세 패러다임은 개발자에게 규칙(제한)을 부과함으로써 해서는 안되는 것들을 정의한다.
- 세 패러다임은 앞으로 나올 아키텍처를 설계하는데에 이용되기도 하고 규칙을 부과하기도 한다.

# 4장 구조적 프로그래밍

- 데이크스트라는 복잡한 프로그램이 예상 외의 방식으로 동작하는 문제를 해결하고자함.
- 증명이라는 수학적 원리를 이용해서 입증된 구조를 만들고 프로그래머는 그 구조를 코드와 결합시킨다. 즉, 코드 스스로 무결성을 입증 할 수있다고 생각함.
- 가능한 작은 단위로 분할해서 상위의 해답을 구하는 분할 정복을 이용하는데 goto문이 방해됨
- 반면 if/then/else, do/while 과 같은 분기,반복 제어구조는 goto문을 사용하더라도 작은 단위로 세분화가능
- 모든 프로그램은 순차, 분기, 반복으로 구성 할 수 있다는 사실과 프로그램의 증명가능한 제어구조(분기,반복)의 최소 집합이 동일하다는 놀라운 사실 발견 ⇒ 증명가능한 제어구조(분기,반복)으로 순차구문의 무결성을 입증할 수있다!(goto가 없다면)
- goto문은 점점 사라졌지만 프로그래머들은 데이크스트라처럼 엄밀한 증명에 관심 없음
- 수학이 하지 못한걸 과학이 해냄. 과학은 관찰과 실험으로 도출된 원리. 증명 할 수 없음. 어떤 서술이나 사실에 반대되는 근거를 들어 반증 할 수는 있음
- 최선의 테스트를 통해 버그가 있음을 증명하지 못한다면 버그가 없다는 반증이 될 수 있음
- 테스트를 하기위해서는 위에서 언급한 반증 가능한 세부 단위(분기,반복)여야함
- 소프트웨어 아키텍트는 구조적 프로그래밍의 제한을 받아들여 모듈, 컴포넌트, 서비스를 반증 가능한 단위로 만들기 위해 노력해야함.
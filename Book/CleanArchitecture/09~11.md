# 9장 LSP: 리스코프 치환 원칙

- 만약 S타입의 객체가 T타입 객체의 하위타입이라면 T타입을 사용하는 프로그램 P에서는 변경 없이 T타입을 S타입으로 교체할 수 있어야한다.

## 상속을 사용하도록 가이드하기

- 상속을 이용해서 하위타입을 구현하면 두 하위 타입 각각은 상위 타입을 대체할 수 있다.

## 정사각형/직사각형 문제

- 정사각형은 높이와 너비가 함께 변경되고 직사각형은 높이와 너비가 독립적으로 변경될 수 있음

  정사각형은 직사각형의 하위타입으로 적합하지 않으므로 정사각형은 직사각형을 대체할 수 없다.

- 하위타입으로 적합하지 않은 경우에 상속을 구현하면 LSP를 위반하게된다.

## LSP와 아키텍처

- 초기에는 상속을 사용하도록 장려하는 정도였음
- 시간이 지나며 광범위한 설계 원칙으로 변모
- 인터페이스의 구현체들끼리 상호 치환이 가능하다!

## LSP 위배 사례

- 여러개의 택시 파견 서비스를 통합하는 어플리케이션을 만들때 택시를 고객의 위치로 파견하는 REST 서비스의 URI가 있다.

  이때 REST 인터페스를 치환 불가능하게 구현하면 각각의 택시파견 업체마다 예외처리를 해줘야함

  혹은 모든 업체들이 하나의 REST 인터페이스를 준수하도록 해야함.


## 결론

- LSP는 아키텍처 수준까지 확장 가능하며 해야한다.
- 항상 치환 가능성을 열어두고 아키텍처를 설계해야한다.

# 10장 ISP: 인터페이스 분리 원칙

- OPS 클래스에 op1, op2, op3 메서드가 구현되어있다.

  다수의 User가 OPS클래스의 메서드를 사용한다.

  user1은 op1을, user2은 op2을, user3은 op3을 사용할때 각 유저들은 사용하지 않는 메서드에 의존성을 갖게 된다.

  때문에 op2에 변경이 발생하면 user1과 user3도 재컴파일 해야한다.

- op1, op2, op3를 인터페이스단위로 분리하고 각 유저는 사용하는 메서드가 구현된 인터페이스에 의존하도록 함으로써 불필요한 재컴파일을 막을 수 있다.

## ISP와 언어

- 정적 타입 언어는 import, use, include같은 타입 선언문을 강제하기때문에 소스 코드에 의존성이 발생함 → 재컴파일,재배포 해야함
- 동적 타입 언어는 런타임에 타입을 추론하기때문에 소스 코드에 의존성이 없음 → 재컴파일, 재배포 필요 없음
- ISP는 언어의 종류에 따라 영향을 받는다.
- 동적 타입의 언어를 사용할때 더 유연한 시스템을 만들 수 있다.

## ISP와 아키텍처

- 일반적으로 필요 이상으로 많은걸 포함하는 모듈에 의존하는것은 좋지 않다.

  불필요한 재컴파일과 재배포를 해야하는 상황이 생길 수 있기때문

- ISP를 준수하지 않으면 System(S) → Framework(F) → Database(D) 구조의 아키텍처에서 S와 관계없는 기능이 D에 있고 이 기능에 변경이 발생하면 F와 S를 재배포해야하는 상황이 생길 수도 있다.

## 결론

- 불필요한 요소에 의존하지 않도록하자. 예상치 못한 오류가 생길 수 있다.

# 11장 DIP: 의존성 역전 원칙

- 유연성이 극대화된 시스템이란 소스 코드가 추상에 의존하고 구체에는 의존하지 않는 시스템이다.

  현실적으로 구체에 의존하지않을 수는 없다. Stirng같은 구체 클래스에 의존하지 않을 수 없는것처럼

  하지만 String클래스는 변경될일이 없는 매우 안정적인 클래스이기때문에 이 경우의 의존은 무시해도 괜찮다.

- 의존을 피해야하는 클래스는 변동성이 큰 구체 클래스다.

## 안정된 추상화

- 추상 인터페이스와 이를 구체화한 구현체들이 있을때

  인터페이스 변경 → 구현체 변경

  구현체 변경 → 인터페이스 변경 X

  ⇒ 인터페이스의 변동성이 더 낮다.

- 뛰어난 아키텍트라면 인터페이스의 변동성을 낮추고 변동성이 큰 구현체에 의존하지 않도록 힘써야함
- DIP 실천법
    - 변동성이 큰 구체 클래스를 참조하지 말라.
        - 대신 추상 인터페이스를 참조하라.
        - 객체 생성 방식을 강하게 제약함
    - 변동성이 큰 구체 클래스로부터 파생(상속)하지 말라.
        - 상속은 강력한 관계인 만큼 자식에 강한 의존성을 부여하게된다.
    - 구체 함수를 오버라이드 하지 말라
        - 대체로 소스 코드 의존성을 갖고 있는 구체 함수를 오버라이드하게되면 오버라이드한 함수로 의존성을 상속하게됨
    - 구체적이며 변동성이 크다면 절대 그 이름을 언급하지 말라.
        - 다시말해 변동성이 큰 구현체에 의존하지 말라는말

## 팩토리

- 변동성이 큰 구체 객체를 생성할때는 주의해야한다.
- 모든 언어에서 객체를 생성할때 해당 객체를 정의한 코드에 대해 소스 코드 의존성이 발생한다.
- 이런 소스 코드 의존성을 방지하기위해 추상 팩토리를 사용한다.
- 객체 생성을 소스 코드에 의존하지않기 위해 추상화 팩토리를 구현한 구체 팩토리의 객체 생성 메소드를 호출한다.
- 객체 생성마저도 추상화 컴포넌트를 통함으로써 추상 컴포넌트와 구체 컴포넌트는 경계를 두고 분리됨

## 구체 컴포넌트

- 위 예에서 구체 팩토리가 객체를 생성하면서 의존성이 하나 생길 수밖에없는데 이처럼 DIP 위배를 완전하게 없애는건 불가능하다.
- 대신 이런 DIP에 반하는 클래스들을 소수의 구체 컴포넌트에 모아서 시스템과 분리하여 관리 할 수 있다.

## 결론

- DIP는 고수준의 아키텍처를 다룰때 꼭 필요한 개념
- DIP가 발생하는 지점은 구체적인 요소와 추상적인 요소를 나누는 아키텍처의 경계가 된다.
- 이 경계를 기준으로 의존성은 추상적인 요소를 향한다.
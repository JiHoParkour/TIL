# 15장 아키텍처란?

시스템의 형태로서 시스템을 구성하는 컴포넌트가 어떻게 분할되어있는지, 어떻게 배치되었는지, 어떻게 의사소통하는지에 따라 모양이 정해진다.

소프트웨어 아키텍트도 역시 프로그래머이기 때문에 코딩과 아주 동떨어질 순 없음

코딩을 하면서 발생하는 문제점을 경험해봐야 다른 프로그래머에게 도움을 줄 수 있기 때문

아키텍트는 시스템의 동작 여부보다 유지보수에 중점을 두어야 한다.

유지보수를 용이하게 하려면 가능한 많은 선택지를, 가능한 한 오래 남겨두는 전략을 따라야 함

### 개발

아키텍처는 팀이 개발을 쉽게 할 수 있도록 도와야 한다.

대개 작은 인원으로 이루어진 개발팀은 아키텍처 관련 제약들이 개발에 방해가 된다고 여기기 때문에 아키텍처가 결여된 채로 개발한다.

반대로 많은 인원으로 이루어진 개발팀은 잘 설계된 아키텍처 없이는 개발이 진척되지 않는데 각 팀이 독자적인 단일 컴포넌트 아키텍처를 채택하고 있을 가능성이 큼

### 배포

아키텍처는 시스템을 적은 비용으로 쉽게 배포할 수 있게 만들어야 한다.

초기 개발 단계에서 이런 전략을 고려하지 않으면 개발은 쉽게 할지 몰라도 배포하기 어려운 시스템이 만들어진다.

### 운영

아키텍처가 시스템 운영에 미치는 영향은 개발과 배포, 유지보수에 미치는 영향보다는 적지만 의의가 없지는 않다.

아키텍처는 시스템을 운영하는데 필요한 요구사항을 개발자들이 쉽게 인식할 수 있도록 드러낼 수 있음

유스케이스, 기능, 시스템의 필수 행위를 일급 Entity로 격상시키는 것임

### 유지보수

소프트웨어 시스템은 유지보수에 가장 큰 비용이 발생한다.

끝없이 새로운 기능을 추가하고 뒤따르는 결함을 수정해야 하기 때문

잘 설계된 아키텍처는 추가될 기능에 대한 가능성을 열어둠으로써 유지보수에 드는 비용과 위험을 크게 줄일 수 있음

### 선택사항 열어 두기

소프트웨어는 기계의 행위를 빠르고 쉽게 변경하기 위해서 만들어졌음

그러기 위해서는 선택사항을 가능한 한 많이, 오랫동안 열어두어야 함

아키텍처는 소프트웨어 시스템을 정책과 세부 사항으로 나눠야 함

업무 규칙과 절차가 세부 사항에 영향을 받지 않도록 만들면 중요치 않은 세부 사항의 결정을 최대한 뒤로 미룰 수 있음

ex) 데이터베이스, 웹서버, REST, DI 프레임워크 등

세부 사항 결정을 미루는 동안 다양한 실험을 해볼 수 있고 최적의 결정을 내릴 수 있다.

### 결론

아키텍트는 정책과 세부 사항을 엄격하게 분리해서 세부 사항에 대한 결정을 최대한 미룰 수 있도록 설계해야 함

# 16장 독립성

아키텍처는 시스템의 생애 즉, 시스템의 유스케이스, 운영, 개발, 배포를 지원해야 한다.

### 유스케이스

아키텍처는 유스케이스를 최우선으로 두어야 한다.

아키텍처는 시스템의 행위와 관련해서 선택사항을 열어 둘 수는 없지만

유스케이스를 시스템의 최상위 수준 일급 요소로 격상시킴으로써

개발자들이 알아보기 쉽게 행위를 명확하게 드러낼 수는 있다.

### 운영

운영에 있어서 아키텍처는 더 실질적인 역할을 맡을 수 있다.

만약 아키텍처가 각 컴포넌트를 적절히 분리하고 선택사항을 잘 열어두었다면 운영에 필요한 요구사항이 바뀌었을 때 변화를 쉽게 적용할 수 있을 것임

ex) 단일 서비스 모든 구성요소가 통합되어있는 모놀리틱 프로그램에서 여러 개의 독립 서비스로 구성되어 API로 통신하는 마이크로서비스 형태로 전환하기

### 개발

시스템의 설계는 해당 시스템을 만드는 조직의 의사소통 구조와 동일하다는 콘웨이의 법칙이 작용한다.

아키텍처는 각 팀이 독립적으로 행동하고 의사소통하기 편한 형태로 분리된 컴포넌트들로 구성되어야 한다.

그래야만 컴포넌트들을 각 팀에 할당 할 수 있다.

### 배포

좋은 아키텍처는 시스템 빌드 후 설정을 수정하거나 하는 일 없이 즉각적인 배포를 할 수 있도록 지원해야 한다.

즉각적인 배포가 가능하게 하려면 시스템을 컴포넌트 단위로 적절하게 분할해야 한다. 컴포넌트들을 통합해서 바르게 구동하는 마스터 컴포넌트도 포함된다.

### 선택사항 열어놓기

유스케이스, 운영, 개발, 배포 각 주제 사이에서 균형을 맞추고 모두 만족시키는 것은 매우 어렵다.

하지만 앞서 등장한 아키텍처 원칙을 이용하면 선택사항을 최대한 오래 열어둘 수 있음

즉, 시스템에 변경이 필요할 때 쉽게 할 수 있게 됨

### 계층 결합 분리(수평 분리)

유스케이스의 측면부터 시작하자면 아키텍트는 모든 유스케이스를 알 수는 없지만, 시스템의 기본적인 의도는 알 수 있다.

이런 의도를 따라 같은 이유로 변경되는 것들을 묶고, 다른 이유로 변경되는 것들을 분리함으로써 단일 책임 원칙과 공통 폐쇄 원칙을 적용할 수 있다.

비슷한 맥락으로 유스케이스에서 UI가 변경되는 부분과 업무 규칙 부분을 분리할 수 있다.

시스템을 다른 이유로 변경됨을 기준으로 분리하다 보면 수평적인 계층으로 분리할 수 있다.

ex) UI, 애플리케이션에 특화된 업무 규칙, 애플리케이션과 독립적인 업무 규칙, 데이터베이스 등

### 유스케이스 결합 분리(수직 분리)

유스케이스 자체도 다른 이유로 변경되기 때문에 분리해야 한다.

ex) 주문을 추가하는 유스케이스와 주문을 삭제하는 유스케이스

각 유스케이스는 UI의 일부, 애플리케이션 특화 업무 규칙 일부, 애플리케이션 독립적 업무 규칙 일부, 데이터베이스 기능의 일부를 사용한다.

따라서 시스템을 수평적 계층 분할하는 동시에 해당 계층을 가로지르는 수직적인 유스케이스로 분할 할 수 있다.

위와 같이 결합을 분리하려면 유스케이스마다 사용하는 UI, 업무규칙, 데이터베이스 기능을 겹치지 않게 해야 한다. 그러면 새로운 유스케이스를 추가하더라도 기존의 유스케이스에는 영향을 주지 않을 수 있다.

### 결합 분리 모드

위와 같이 수평, 수직 형태로 결합을 분리하면 운영 관점에 이점이 있을 수 있다.

만약 컴포넌트가 독립된 서비스 수준까지 분리되어 있다면 높은 처리량이 요구되는 유스케이스는 여러 서버에 복제해서 실행해서 처리할 수 있다.

마이크로 서비스나 서비스 지향 아키텍처를 채택해야 한다는 말이 아니라 둘 중 하나를 채택하던 선택을 유보하던 이 또한 선택지라는 것이다. 변화를 쉽게 적용할  수 있으니까

### 개발 독립성

컴포넌트가 분리되어있는 형태를 따라 개발 또한 독립적으로 할 수 있다.

(수평 계층) UI에 중점을 둔 팀 vs 업무 규칙에 중점을 둔 팀

(수직 계층) addOrder유스케이스에 중점을 둔 팀 vs deleteOrder에 중점을 둔 팀

위 팀들이 서로 영향을 줄 일은 거의 없다.

### 배포 독립성

유스케이스와 계층 결합이 잘 분리되어 있다면 운영 중인 시스템에 새로운 유스케이스를 추가하는 일은 안전하고 쉽다.

### 중복

중복에는 진짜 중복과 우발적인 중복이 있다.

진짜 중복은 변경이 생기면 해당 중복의 모든 곳에 변경을 적용해줘야 한다.

우발적인 중복은 해당 중복이 각자 다른 경로로 발전한다거나 다른 이유로 변경된다.

유스케이스를 수직으로 분리할 때, 혹은 계층을 수평으로 분리할때 우발적인 중복을 제거해버리는 일을 주의해야 한다.

### 결합 분리 모드(다시)

계층과 유스케이스는 다양한 수준(모드)에서 분리할 수 있음

- 소스 수준 분리 모드

  모노리틱 구조로서 소스 코드 모듈 사이의 의존성을 제어한다. 어떤 모듈이 변경하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 할 수 있음

- 배포 수준 분리 모드

  jar, DLL, 공유 라이브러리 등 배포할 수 있는 단위들 사이의 의존성을 제어한다. 어떤 모듈의 코드가 변경되어도 재빌드나 재배포하지 않도록 할 수 있음

- 서비스 수준 분리 모드

  모든 모듈이 서로 독립된 서비스로서 네트워크 패킷을 통해서만 통신하도록 만들 수 있다. 모든 실행 가능한 단위는 완전한 독립을 이룰 수 있음


어떤 모드가 정답이라고는 할 수 없지만, 프로젝트가 성숙해갈수록 최적인 모드가 달라질 수 있다.

프로젝트 초기에는 소스 수준 분리 모드로 충분할 수 있지만 시스템이 성장하면 별도 서버에서 실행해야 하는 컴포넌트가 생길 수도 있음

처음부터 서비스 수준까지 분리하는 건 비용이 많이 들고 분리 단위가 너무 커지게 되는 문제점이 있다. 또한 불필요한 서비스 경계를 처리하느라 드는 인력 또한 비효율적이다.

가장 이상적인 방법은 세 가지 분리 모드의 전환을 쉽게 할 수 있는 상태를 유지하는 것

즉, 결합 분리 모드를 선택사항으로 남겨두는 것

좋은 아키텍처는 이러한 변경으로부터 소스 코드 대부분을 보호한다.

### 결론

결합 분리 모드를 변경하는 것은 쉬운 일이 아니지만 뛰어난 아키텍트라면 이러한 변경을 예측하고 적용할 수 있도록 만들어야 한다.
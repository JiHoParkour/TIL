# 7장 어댑터 패턴과 퍼사드 패턴

### 어댑터 패턴

**어댑터의 역할**

어댑터란 어떤 인터페이스를 다른 인터페이스로 변환해주는 일을 함

110v와 220v를 변환해주는 플러그를 떠올려보자.

객체지향 언어에서 어댑터의 역할도 비슷하다.

어떤 업체에서 제공한 클래스 라이브러리를 사용해야 하는데 그 업체에서 사용하는 인터페이스와 기존 코드의 인터페이스가 다르다고 할 때 중간에 기존의 인터페이스를 업체의 인터페이스에 맞게 변환해주는 어댑터를 둘 수 있다.

**어댑터 패턴 정의**

어댑터 패턴은 특정 클래스 인터페이스를 다른 인터페이스로 변환함으로써 인터페이스가 호환되지 않아서 사용 할 수 없었던 클래스를 사용 할 수 있게 해준다.

어댑터 패턴은 변환하고자 하는 어댑티를 새로운 인터페이스로 감쌀 때 구성을 사용함. 따라서 어댑티의 모든 서브클래스에 어댑터를 쓸 수 있음

그리고 구상클래스가 아닌 인터페이스에 맞춰서 구현하기 때문에 다른 구현을 쉽게 추가 가능

**어댑터 패턴 종류**

어댑터 클래스에서 어댑티를 변환할 때 구성을 사용 → 객체 어댑터

어댑터 클래스에서 어댑티를 변환할 때 (다중)상속을 사용 → 클래스 어댑터

둘 다 어댑티 클래스를 클라이언트에서 요구하는 타겟 인터페이스에 맞게 변환 해주는 점은 동일!

하지만 객체 어댑터는 구성을 사용하기 때문에 어댑티의 모든 서브클래스를 변환할 수 있고 어댑티를 동적으로 바꿀 수 있다.

상속을 사용한 클래스 어댑터는 특정 클래스의 어댑티만 변환 할 수 있으며 다중상속이 가능해야 함

**데코레이터 패턴과의 차이점**

데코레이터 패턴 - 감싸고 있는 구성 요소의 메소드를 호출한 결과에 새 기능을 더함으로써 기능 확장

어댑터 패턴 - 타겟 인터페이스의 메소드를 호출을 감싸고 있는 구성 요소의 메소드로 변환



객체를 감싸는게 겉보기엔 조금 비슷해 보이지만 데코레이터 패턴은 객체의 행동과 책임 확장, 어댑터 패턴은 인터페이스의 변환에 중점을 두고 있음

### 퍼사드 패턴

**인터페이스를 변경하는 이유**

어댑터 패턴은 어떤 클래스의 인터페이스를 클라이언트에서 원하는 인터페이스로 변환한다.

하지만 단순히 인터페이스를 변경하고싶을때는? 퍼사드 패턴을 사용 할 수 있음

**퍼사드 패턴의 정의**

퍼사드 패턴은 서브시스템에 있는 여러 일련의 인터페이스를 통합 인터페이스로 묶어준다.

즉 퍼사드 하나를 통해 모든 서브시스템의 기능을 활용 할 수 있게 됨.

덕분에 클라이언트와 복잡한 서브시스템은 분리되고 서브시스템의 변경이 클라이언트에 영향을 미치지 않게 됨

**최소 지식 원칙**

객체 사이의 상호작용은 정말 가까운 친구 사이에서만 해야 한다. 한 다리 건너 친구를 사귀지 말라는건지 친구 수를 최소로 줄이라는건지? 둘 다 같음

가까운 친구 사이란?

- 객체 자체
- 메소드에 매개변수로 전달된 객체
- 메소드를 생성하거나 인스턴스를 만든 객체
- 객체에 속하는 구성 요소

퍼사드 패턴을 사용하면 클라이언트는 퍼사드만 알면 되기 때문에 최소 지식 원칙을 따를 수 있음
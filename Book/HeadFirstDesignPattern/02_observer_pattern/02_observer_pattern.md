# 2장 옵저버 패턴

객체에세 변경 사항을 알릴 수 있는 패턴! 1:n 관계에 유용하다~

78p. 예시 코드의 설명으로 옳은것은?

A. 인터페이스가 아닌 구체적인 구현을 바탕으로 코딩을 하고 있습니다.

선언된 인터페이스도 없고 3가지 디스플레이의 구상클래스를 이용하고 있기 때문에

B. 새로운 디스플레이 항목이 추가될 때마다 코드를 변경해야 합니다.

구체적인 디스플레이 클래를 이용하기 때문에

C. 실행 중에 디스플레이 항목을 추가하거나 제거할 수 없습니다.

위와 같음. 정해진 디스플레이만 업데이트 할 수 있다.

D.디스플레이 항목들이 공통적인 인터터페이스를 구현하지 않습니다.

그렇다

E. 바뀌는 부분을 캡슐화하지 않았습니다.

바뀌는 부분 = 디스플레이

F. WeatherData 클래스를 캡슐화 하지 않고 있습니다.

내가 생각하는 캡슐화의 의미는 다른 객체들로 부터 경계를 만들고 분리하는것. 그리고 그 안의 내용을 직접적, 구체적으로 알지 못하게 하는것임

캡슐화 : 객체의 속성과 행위를 하나로 묶고, 실제 구현 내용 일부를 내부에 감추어 은닉한다.

→ 무조건 감추는게 아니라 감출 것과 드러낼 것을 적절히 설계해야 하는구나

그런면에서 메소드가 하나밖에 없는데 그것마저도 감추면 WeatherData클래스가 의미 없어진다고 생각해서 캡슐화 한것 같음

94p. 기상 측정치를 Observer에게 직접 전달하는게 가장 간단한 방법일까? 이 부분이 나중에 바뀔 가능성은? 그렇다면 그 변경사항이 캡슐화 된건가? 아니면 여러군데 고쳐야하는가?

당장은 온도,습도,기압 세가지 속성만 전달하면 되서 간단한 방법은 맞다고 생각한다. 새로운 센서가 추가되서 기상 측정 데이터가 바뀔 가능성이 있다고 생각함. 지금은 속성들이 각각전달되기때문에 캡슐화되었다고 보기 어렵다. 그리고 측정 항목에 변경이 발생하면 매개변수 정의하는 부분을 여러군데 고쳐야함

디자인 원칙이 옵저버 패턴에서 어떤 식으로 쓰이는지 설명

앱에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.

WeatherData클래스에서 변경 가능성이 높은 디스플레이객체를 분리해서 DisplayElement 인터페이스를 정의했다.

→ 좀더 옵저버 패턴의 관점에서 보면 변하는 것은 **주제의 상태**와 **옵저버의 개수, 형식**이다. 옵저버 패턴에서는 주제를 변경하지 않고도 옵저버를 변경 할 수 있음

구현보다는 인터페이스에 맞춰서 프로그래밍한다.

상호 작용하는 객체간 결합을 느슨하게 하기 위해 인터페이스를 사용했음. 주제는 소식을 전해야 하는 객체가 옵저버 인터페이스를 구현한다는 것 외엔 알지 못함

상속보다는 구성을 활용한다.

구성은 ‘A에는 B가 있다’관계. 그리고 주제와 옵저버가 서로 협조하는 방식을 생각 하면..

1. 옵저버를 구현한 Display클래스에서 주제를 구현한 WeatherData 클래스에게 나를 구독자로 등록시켜줘!
2. WeatherData클래스는 Observer리스트를 갖고 있다가 변경이 발생했을때 구독자들에게 알림을 보낸다.

이때 ObserverList를 갖고 있는게 구성을 활용한거 아닐까
싱글턴 패턴이란 클래스의 인스턴스를 한 개만 생성하고 그 인스턴스에 어디서든 접근 할 수 있도록 하는 패턴

### 학습 목표

- 싱글턴 인스턴스를 생성할 수 있다.
- 싱글턴 인스턴스를 사용할 때 주의해야 할 점과 해결방법을 안다.

## 싱글턴 인스턴스를 만드는 방법(Swift)

```swift
class Singleton {
	static let shared = Singleton()

	private init() { } //외부에서 또 다른 인스턴스 생성 되는 것 방지
}
```

Swift에선 기본적으로 **static을 이용해 인스턴스를 생성**하면 1. 사용시점에 초기화됨 따라서 최초 생성되며 사용되기 전엔 메모리에 올라가지 않음

그리고 Objective-C에서 싱글턴 객체가 한 번만 생성 되도록 하는 전역함수 dispatch_once가 제공하는 것과 같은, 2. 한 번만 호출되는 걸 보장하는 thread-safety 전역 프로퍼티를 얻을 수 있음

## ❗싱글턴 객체를 사용할 때 주의해야 할 점(JAVA)

2개 이상의 스레드에서 싱글턴 객체에 접근할 때 유일해야 할 싱글턴 객체가 여러개 만들어 질 수도 있음 ( ex.동시에 getInstance() 에 처음 접근하는 경우)

## 멀티스레딩 환경에서의 문제점 해결하는 방법(JAVA)

1. 싱글턴 객체를 얻는 getInstance() 메소드를 동기화 해서 한 스레드에서 getInstance()를 다 사용한 후 다른 스레드에서 getInstance()를 사용 할 수 있도록 한다. 메소드 전체를 동기화 하면 싱글턴 객체가 이미 만들어졌는데도 불구하고 계속 순차 처리를 해야 하므로 성능 저하가 일어날 수 있지만 간단한 방법임
2. 필요할 때 싱글턴 객체를 만드는게 아니라 클래스가 로딩 될 때 싱글턴 객체를 만든다. 그러면 여러 스레드에서 동시에 접근해도 생성 과정 없이 만들어 놓은 객체를 리턴하기 때문에 thread-safe하다. 역시 간단한 방법이지만 클래스가 복잡하고 크면 불필요한 자원을 쓰게 될 수 있음
3. getInstance() 전체를 동기화 하는 대신 싱글턴 객체가 아직 안만들어져서 생성해야 할 때만 동기화 한다. 첫 호출 때만 동기화가 일어나므로 메소드 전체를 동기화 해서 발생할 수 있는 성능 저하를 개선할 수 있다.

## enum의 특징

1. enum은 각 인스턴스의 값이 하나씩 존재해야 함. 값 복제가 일어나지 않음. 따라서 싱글턴 상태를 유지함
2. enum은 기본적으로 serializable 이 가능해서 해당 인터페이스를 구현할 필요가 없어서 역직렬화 시 새로운 객체가 생성되지 않음. (인터페이스를 구현하면서 작성한 코드때문에 역직렬화 시 새 객체가 반환되는 것 같음)
3. enum의 생성자는 단 하나임(sole construcor). 컴파일러에서 사용하고 사용자가 직접 할 호출 할 수 없기 때문에 reflection을 이용해 객체 생성 불가능

리플렉션 - 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API

리플렉션을 이용하면 런타임에 private 생성자에 접근하여 새로운 인스턴스를 생성할 수 있다

역직렬화 시 새로운 인스턴스가 반환되므로 readResolve를 사용해서 싱글턴 객체를 반환하도록 해야함

transient - 직렬화에서 제외하고싶을때 사용하는 키워드
# 1장 디자인 패턴 소개와 전략 패턴

### 오리 시뮬레이션 게임

오리 시뮬레이션 게임 예를 통해 전략 패턴을 알아보자.

조라는 사람이 오리가 헤엄치고 꽥꽥거리는 오리 시뮬레이션 게임을 만드는 회사에 다니고 있다.

이 시스템은 아래와 같이 Duck 이라는 슈퍼클래스와 그 클래스를 확장해서 다른 종류의 오리들을 구현함

```swift
class Duck {
func quack() { }
func swim() { }
func display() { }
}

class MallardDuck: Duck {
func display() { }
}

class RedheadDuck: Duck {
func display() { }
}
```

별안간 조는 임원진으로부터 오리가 날아다니게 해달라는 요청을 받게 되었음



### 상속으로 해결하기

조는 슈퍼클래스 Duck에 fly()라는 메소드를 추가해서 다른 오리들이 모두 상속받도록 구현함

❗ **심각한 문제 발생**

고무오리가 날아다닌다!

조는 몇몇 서브클래스는 날지 않아야 한다는 사실을 깜빡했음 하지만 상속 때문에 고무오리도 날아 다니게 되어버림

```swift
class Duck {
func quack() { }
func swim() { }
func display() { }
func fly() { }
}

class RubberDuck: Duck {
func display() { }
func fly() {
//아무것도 하지 않도록 오버라이드
}

class WoodDuck: Duck {
func display() { }
func fly() {
//아무것도 하지 않도록 오버라이드
}
```

상속으로 문제를 해결 할 수 있을 줄 알았지만 **예기치 않은 동작이 발생**하는 것과 날지 않는 오리 **서브클래스를 생성 할 때 마다 fly()에 날지 않게 오버라이드** 해야 하는 문제가 있음

코드가 중복 될 뿐더러 fly()라는 오리의 행동을 관리하기도 힘들다.



### 인터페이스 설계하기

상속이 옳은 방법이 아니라는 것을 알게 됐음. 그렇다면 flyable, quackable이라는 인터페이스를 만들어서 각각 날 수 있는 오리들과 꽥꽥거릴 수 있는 오리들에게만 그 인터페이스를 구현하게 하는 것은 어떨까?

```swift
class Duck {
func quack() { }
func swim() { }
func display() { }
func fly() { }
}

protocol Flyable {
func fly() { }
}
protocol Quackable {
func quack() { }
}

class MallardDuck: Duck, Flyable, Quackable  {
func display() { }
func fly() { }
func quack() { }
}

class RubberDuck: Duck {
func display() { }
}
```

이 또한 매번 **인터페이스를 구현해야 하는 부분에서 코드의 중복이 발생**하는 문제가 있음. 코드를 재사용 하지 않기 때문에 코드 관리 또한 어려움



### 어떻게 하면 좋을까?

문제를 해결하기 전 알아야 할 것

소프트웨어는 변화와 함께 한다는 절대 진리



### 문제를 명확하게 파악해보자

첫 번째 방법 상속은 그리 좋은 생각이 아니었다. 서브 클래스 마다 행동이 바뀔 수 있는데도 불구하고 모두 한 가지 행동만 사용 하도록 하는 건 옳지 못함

두 번째 방법 인터페이스 또한 인터페이스에는 구현된 코드가 없으므로 코드를 재사용 할 수 없었다. 한 가지 행동을 바꿀 때 마다 그 행동을 구현한 서브클래스를 찾아서 일일이 고쳐야함



### 디자인 원칙 1

> 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.


바뀌는 부분을 따로 뽑아서 캡슐화하면 바뀌지 않는 부분에 영향을 미치지않고 바뀌는 부분만 고치고나 확장 할 수 있다.

개방 폐쇄 원칙(Open Close Principle)이다!



### 바뀌는 부분과 그렇지 않은 부분 분리하기

첫 번째 디자인 원칙을 적용해보자!

Duck 클래스는 fly()와 quack() 문제를 제외하면 잘 작동하고, 그 외에는 자주 바뀌지 않는다. 그래서 그대로 둔다.

변화하는 부분은 fly()와 quack()이다. 이 두 가지를 Duck 클래스에서 꺼내서 각각 새로운 클래스 집합으로 정의한다.

오리의 행동을 디자인하는 방법



### 41p. 다음 중 Duck의 행동을 상속할 때 단점이 될 수 있는 요소를 모두 고르시오.

A. 서브클래스에서 코드가 중복된다.

일반적인 경우 Duck의 외모가 각기 다르기때문에 display()를 오버라이드하는건 코드의 중복이 일어나지 않는다. 하지만 날 수 없는 오리들 모두 아무것도 하지 않도록 fly()를 오버라이드는 부분은 중복될 것 같다.

B. 실행 시에 특징을 바꾸기 힘들다.

실행 시는 런타임을 뜻하는 건가? 슈퍼클래스 Duck을 상속한 서브클래스의 특징을 런타임에 바꿀 수 있나? 상속을 통해 날아다닐 수 있었던 오리들을 런타임에 날지못하게 바꿀 방법이 떠오르지 않는다.

C. 오리가 춤추게 만들 수 없다.

슈퍼클래스에 fly()를 추가해서 모든 오리들이 날 수 있게 만든것 처럼 dance()를 추가하면 오리들이 춤추게 만들 수 있지 않을까?

D. 모든 오리의 행동을 알기 힘들다.

서브클래스 오리들의 행동은 슈퍼클래스 Duck의 행동들을 상속받은것이기 때문에 알 수 있지 않을까? 하지만 서브클래스에서 추가로 정의한 행동들이나 상속받은 행동을 재정의 한 것 들은 알기 힘들다. 상속 할때 단점이니까 후자는 상관없겠다.

→라고 생각했지만 D도 상속할때의 단점이다. 아마 내가 생각했던 후자의 경우도 포함인가보다.

E. 오리가 날면서 동시에 꽥꽥거릴 수 없다.

quack()과 fly() 모두 상속 받았으면 동시에 날면서 꽥꽥거릴 수 있지 않을까?

F. 코드를 변경했을 때 다른 오리들에게 원치 않은 영향을 끼칠 수 있다.

수퍼클래스에 fly()를 추가해서 날지 않아야 하는 고무오리가 날게 된 것 처럼 원치 않는 영향을 끼칠 수 있다.



### 44p. 앱을 만드는 과정에서 코드를 바꿔야 했던 이유를 적어보세요.

1. 기존 코드로는 앱에서 메모리 누수가 발생해서 수정해야했었다.
2. 앱 UI 디자인이 변경되어서 새로운 디자인으로 변경하는 경우
3. 버그 혹은 예기치 못한 동작때문에 급하게 수정하는 경우
4. 복잡했던 로직을 간단명료하게 리팩토링 하는 경우
5. 서버 api가 변경되어서 수정하는 경우